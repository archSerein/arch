module alu(
    input [31:0] r1_data,
    input [31:0] r2_data,
    input [3:0] fn,
    output [31:0] y,
    output Z
);

    // 连接中间信号
    wire [31:0] a, S, b, cmp;
    wire Z, V, N;

    // 算术模块 
    arith arith_module(
        .x(r1_data),
        .y(r2_data),
        .AFN(fn[1]),
        .S(S),
        .Z(Z),
        .V(V),
        .N(N)
    );

    // 比较模块
    cmp cmp_module(
        .Z(Z),
        .V(V),
        .N(N),
        .fn(fn[3:2]),
        .cmp(cmp)
    );

    // 移位模块
    shift shift_module(
        .x(r1_data),
        .y(r2_data[4:0]),
        .fn(fn[1:0]),
        .out(b)
    );

    // 布尔计算模块
    bool bool_module(
        .a(r1_data),
        .b(r2_data),
        .fn(fn[3:0]),
        .S(a)
    );

    // 选择需要的输出
    
    wire [31:0] shift_out, cmp_out, arith_out, bool_out;
    assign cmp_out = fn[5:4] == 2'b00 ? cmp : 32'h0;
    assign arith_out = fn[5:4] == 2'b01 ? S : 32'h0;
    assign bool_out = fn[5:4] == 2'b10 ? a : 32'h0;
    assign shift_out = fn[5:4] == 2'b11 ? b : 32'h0;

    assign y = cmp_out | arith_out | bool_out | shift_out;
    assign Z = y == 32'h0 ? 1'b1 : 1'b0;
endmodule

module bool(
    input [31:0] a,
    input [31:0] b,
    input [3:0] fn,
    output [31:0] S 
);

    genvar i;

    generate
        for(i = 0; i < 32; i = i + 1)
        begin   :   bool
            MuxKey #(4, 2, 1) mux (S[i], {a[i], b[i]}, {
                2'b00, fn[0],
                2'b01, fn[1],
                2'b10, fn[2],
                2'b11, fn[3]
                });
        end
    endgenerate
endmodule

